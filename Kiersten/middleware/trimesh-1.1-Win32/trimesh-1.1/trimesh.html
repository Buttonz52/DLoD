<html>
<head>
<title>The TriMesh class</title>
</head>
<body>
<h1>The TriMesh class</h1>

<h3>1. Introduction</h3>
<p>
The <tt>TriMesh</tt> class represents a triangular mesh, together with:
<ul>
<li> information about its vertices and faces
<li> per-vertex properties such as normals and colors
<li> global per-mesh properties like bounding boxes
<li> some connectivity information such as neighboring vertices
</ul>

<p>
The library also contains code for
<ul>
<li> <tt>.ply</tt> file I/O
<li> computing various per-vertex and per-mesh properties
<li> a random collection of utility functions often useful when manipulating
     or displaying meshes
</ul>

<p>
The primary design considerations were ease of coding and space and
time efficiency.

<h3>2. Quick Introduction</h3>
<pre>
#include "trimesh.h"

	// Read a mesh
	TriMesh *mymesh = TriMesh::ReadPly("somefile.ply");
	if (!mymesh) {
		printf("Couldn't read mesh!\n");
		exit(1);
	}

	// If the mesh had triangle strips, unpack them into individual triangles
	if (mymesh->tstrips) {
		mymesh->need_faces();
		mymesh->free_tstrips();
	}

	// Print out some facts about vertices and faces
	printf("The mesh has %d vertices and %d triangles\n",
		mymesh->numvertices, mymesh->numfaces);
	printf("The coordinates of the 17th vertex are %f %f %f\n",
		mymesh->vertices[17][0], mymesh->vertices[17][1], mymesh->vertices[17][2]);
	printf("The 23rd face consists of vertices %d, %d, and %d\n",
		mymesh->faces[23][0], mymesh->faces[23][1], mymesh->faces[23][2]);
	if (mymesh->colors) {
		printf("The color of the 31st face is %d, %d, %d\n",
			mymesh->colors[31][0], mymesh->colors[31][1], mymesh->colors[31][2]);
	} else {
		printf("The mesh does not have per-vertex color\n");
	}


	// Print out some stats
	mymesh->need_bbox();
	printf("The mesh has X ranging from %f to %f, Y from %f to %f, and Z from %f to %f\n",
		mymesh->bbox->xmin, mymesh->bbox->xmax,
		mymesh->bbox->ymin, mymesh->bbox->ymax,
		mymesh->bbox->zmin, mymesh->bbox->zmax);
	printf("The average edge length of the mesh is %f\n", mymesh->meanedgelength());


	// Write out the file
	mymesh->WritePly("someotherfile.ply");

</pre>


<h3>3. Members</h3>
<p>
The <tt>TriMesh</tt> class contains the following member data:
<ul>
<li>
<tt>numvertices</tt> contains the number of vertices in the mesh.

<li>
<tt>vertices</tt> is an array of all the vertex coordinates.
<tt>themesh-&gt;vertices[23]</tt> is a pointer-to-float that points to the
three coordinates of the 24th vertex, and <tt>themesh-&gt;vertices[23][1]</tt>
is the <tt>y</tt> coordinate of that vertex.

<li>
<tt>numfaces</tt> is the number of triangles in the mesh.

<li>
<tt>faces</tt> is an array of faces.  For each face, there are three integers,
representing the indices of the three vertices that make up that triangle. 
That is, <tt>themesh-&gt;faces[34]</tt> is a pointer-to-int that points to
the three indices of the 35th face, <tt>themesh-&gt;faces[34][2]</tt> is the
index of the third triangle of that face, and
<tt>themesh-&gt;vertices[themesh-&gt;faces[34][2]][0]</tt> is the <tt>x</tt>
coordinate of that vertex.

<li>
<tt>colors</tt> is an array of per-vertex colors, accessed in the same way as
<tt>vertices</tt>.  It is present only if the mesh has per-vertex colors; 
otherwise, <tt>colors</tt> will be <tt>NULL</tt>.  The type of a color is
a triple of <tt>unsigned char</tt>s, so the range of each color component is
0 through 255.

<li>
<tt>confidences</tt> is an array of per-vertex confidence values (e.g. as
assigned by VRIP).  As with colors, this is only present if the input mesh
actually had per-vertex confidences.  Confidences are represented as floats.

<li>
<tt>normals</tt> is an array of per-vertex normal vectors. It is only available
after you call <tt>themesh-&gt;need_normals()</tt>. It is accessed in exactly
the same way as the <tt>vertices</tt> array.

<li>
<tt>bbox</tt> is a pointer to a bounding box structure containing the
elements <tt>xmin, xmax, xlen, ymin, ymax, ylen, zmin, zmax, zlen</tt>. 
Call <tt>need_bbox()</tt> before use...

<li>
<tt>bsphere</tt> is a pointer to a bounding sphere structure containing the
elements <tt>center</tt> and <tt>r</tt>, where <tt>center</tt> is a
<tt>point</tt> that lies at the center of the bounding sphere, and <tt>r</tt>
is the radius.  Call <tt>need_bsphere()</tt> to use these.

<li>
<tt>neighbors</tt> is a list of lists of neighboring (i.e. connected by an
edge) vertices.
<tt>themesh-&gt;neighbors[i][j]</tt> is the jth neighbor of vertex i.
<tt>themesh-&gt;numneighbors[i]</tt> is the number of neighbors vertex i has.
Also available are <tt>minneighbors</tt> and <tt>maxneighbors</tt>, which just
contain the minimum and maximum number of neighbors of all the vertices in the
mesh.  As usual, call <tt>need_neighbors()</tt> to generate all of these.

<li>
<tt>adjacentfaces</tt> is a list of lists of faces adjacent to each vertex.
That is, <tt>themesh-&gt;adjacentfaces[i][j]</tt> is the index of the jth
triangle that touches vertex i. <tt>numadjacentfaces[]</tt>,
<tt>need_adjacentfaces()</tt>, <tt>minadjacentfaces</tt>, and
<tt>maxadjacentfaces</tt> also exist.

<li>
<tt>tstrips</tt> is a list of triangle strips, and <tt>tstripdatalen</tt> tells
how long this list is.  The triangle strips themselves are stored as vertex
indices separated by the value -1.  You can cause triangle strips to be built
with the <tt>need_tstrips()</tt> command.  If you have triangle strips but not
faces, you can unpack the triangle strips with the <tt>need_faces()</tt>
command.


</ul>

<p>
The class contains the following member functions:
<ul>

<li>
As mentioned before, the functions <tt>need_normals()</tt>, <tt>need_bbox()</tt>,
<tt>need_bsphere()</tt>, <tt>need_neighbors()</tt>, <tt>need_adjacentfaces()</tt>,
and <tt>need_faces()</tt> cause the specified quantities to be computed.  There
are also <tt>need_colors()</tt> and <tt>need_confidences()</tt> functions that
just allocate space for these quantities if they were not present,

<li>
For each <tt>need_*</tt> function there is a corresponding <tt>free_*</tt>
function that frees the storage associated with those quantities.

<li>
There are functions named <tt>minedgelength()</tt>, <tt>maxedgelength()</tt>,
<tt>rmsedgelength()</tt>, <tt>meanedgelength()</tt>, and <tt>medianedgelength()</tt>,
that return the minimum, maximum, root-mean-square, average, and median edge
lengths for the mesh.  The latter three functions take an optional boolean
parameter (defaults to true) that specifies whether an approximation to the
desired quantity will be computed by taking a random sample of ten thousand
edges.

<li>
The function <tt>RemoveVertices(const vector&lt;bool&gt &toremove)</tt> takes
as an argument a vector of bools of length <tt>numvertices</tt>, where
<tt>toremove[i]</tt> specifies whether the i-th vertex should be removed.
Note that removing vertices also removes their associated normals, colors, and
confidences, and renumbers faces correctly.

<li>
The function <tt>RemoveFaces(const vector&lt;bool&gt &toremove)</tt> is exactly
analogous, but removes faces.

<li>
The function <tt>RemoveUnusedVertices()</tt> simply removes vertices that are
not referenced by any face.  It's often a good idea to follow
<tt>RemoveFaces()</tt> by a call to <tt>RemoveUnusedVertices()</tt>.

</ul>

<h3>4. File input and output</h3>
<ul>
<li>
The static member function <tt>TriMesh::ReadPly(const char *plyfile)</tt> reads
the <tt>.ply</tt> file named by its argument.  It returns a pointer to a
<tt>TriMesh</tt> if it succeeds, else it returns <tt>NULL</tt>.
Note that only a very restricted subset of <tt>.ply</tt> files is supported -
only binary big endian files with vertices and either faces or tristrips.  If
you need more generalized ply I/O routines, look in
<a href="http://graphics.stanford.edu/software/zippack/">http://graphics.stanford.edu/software/zippack/</a>.


<li>
The member function <tt>WritePly(const char *plyfile)</tt> writes a mesh to a
<tt>.ply</tt> file.  Colors and confidences, if present, are saved.  Triangle
strips are written if they are present, else faces are written.  No other
per-vertex or per-mesh quantities are written.

<li>
The function <tt>IsPlyFile(const char *plyfile)</tt> simply reads the header of
the given file and guesses whether it is a <tt>.ply</tt> file.

</ul>

<h3>5. <tt>triutil.h</tt></h3>
<p>
<tt>triutil.h></tt> contains a random collection of occasionally-useful
utility functions.  Most of the functions are templatized, so they can accept
arguments of any type (OK, at least float and double...).  The functions are:
<ul>
<li>
<tt>sqr(x)</tt> and <tt>cube(x)</tt> return the square and cube of <tt>x</tt>.

<li>
<tt>Dot(x,y)</tt> returns the dot product of two 3-vectors

<li>
<tt>Len(x)</tt> and <tt>Len2(x)</tt> return the length and the squared length
of a 3-vector.

<li>
<tt>Dist(x,y)</tt> and <tt>Dist2(x,y)</tt> return the distance and squared
distance between two 3-vectors.

<li>
<tt>CrossProd(x,y,z)</tt> sets <tt>z</tt> to be the cross product of <tt>x</tt>
and <tt>y</tt>.

<li>
<tt>FindNormal(p1,p2,p3,n)</tt> sets <tt>n</tt> to be the normal of a
triangle with vertices at points <tt>p1</tt>, <tt>p2</tt>, and <tt>p3</tt>.
Note that it is not necessarily unit-length.

<li>
<tt>Normalize(v)</tt> normalizes 3-vector <tt>v</tt> (i.e. makes it unit
length).

<li>
<tt>MMult(M1,M2,Mout)</tt> sets <tt>Mout</tt> to be the product of 4x4 matrices
<tt>M1</tt> and <tt>M2</tt>.  All matrices are in OpenGL (column-major) order.

<li>
<tt>Project(P,M,V,vert,coord,zoffset=0)</tt> is a replacement for
<tt>gluProject()</tt>, with an optional additional z offset.

<li>
<tt>FastProjectPrecompute(F,P,M,V,zoffset=0)</tt> sets <tt>F</tt> to be a
matrix that can be used by <tt>FastProject</tt> (below) to accomplish the same
thing as <tt>Project</tt>.

<li>
<tt>FastProject(F,vert,coord)</tt> uses <tt>F</tt> computed by
<tt>FastProjectPrecompute</tt> to do the same thing as <tt>gluProject()</tt>,
but faster.

<li>
<tt>FastProject(F,x,y,z,xout,yout,zout)</tt> is just another way of calling
<tt>FastProject</tt>, specifying the coordinates explicitly as separate
parameters.

<li>
<tt>FastProjectNoZ</tt> does the same thing as <tt>FastProject</tt>, but does
not compute the Z coordinate, so is even faster.

<li>
<tt>FastInvert(matrix)</tt> inverts the given 4x4 matrix.  It assumes that the
matrix represents a rigid-body (just rotation+translation) transformation and
will give incorrect results otherwise.

<li>
<tt>TriBoundingSphere(p1,p2,p3,cent,r)</tt> computes the center and radius of a
sphere that encloses the triangle with vertices <tt>p1</tt>, <tt>p2</tt>, and
<tt>p3</tt>.

<li>
<tt>QNorm(q)</tt> normalizes a quaternion

<li>
<tt>QCompose(q1,q2,q3)</tt> composes the quaternions <tt>q1</tt> and
<tt>q2</tt>, and sets <tt>q3</tt> to the result.

<li>
<tt>RotAndAxis2Q(rot,rotaxis,q)</tt> computes a quaternion from a rotation and
an axis.

<li>
<tt>Q2RotAndAxis(q,rot,rotaxis)</tt> is the reverse of the above.

<li>
<tt>Mouse2TrackballPos(x,y,pos)</tt> takes normalized (-1..1) mouse coordinates
and returns a position on a virtual trackball

<li>
<tt>Mouse2Q(x1,y1,x2,y2,q)</tt> takes normalized mouse positions
<tt>(x1,y1)</tt> and <tt>(x2,y2)</tt> and sets <tt>q</tt> to be the quaternion
representing a rotation achieved by dragging the mouse from <tt>(x1,y1)</tt>
to <tt>(x2,y2)</tt>.

<li>
<tt>QRotate(x,q)</tt> applies the rotation represented by quaternion <tt>q</tt>
to point <tt>x</tt>.

</ul>

<h2>6. Sample source</h2>
<p>
Source code to the following demo programs is provided:
<ul>
<li> <tt>plycat</tt> just reads in a <tt>.ply</tt> file and dumps its vertices
and faces as ASCII.
<li> <tt>plymunge</tt> reads a mesh and performs various trivial changes.  Run
<tt>plymunge -h</tt> for details.
<li> <tt>plyv</tt> is a very bare-bones OpenGL-based viewer for <tt>.ply</tt>
files.
</ul>

<p>
<br>
<hr>
Last update:
Mon Nov 16 23:23:28 CET 1998
<address><a href="mailto:smr@cs.stanford.edu">smr@cs.stanford.edu</a></address>
</body>
</html>
